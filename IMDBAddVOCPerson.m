function [ imdb, select ] = IMDBAddVOCPerson( imdb, path, task_num, varargin )
% IMDBADDVOCPERSON   Add to imdb the PASCAL VOC dataset.
%   Input:
%     PATH struct generated by GETPATH() with path.path_OrigNetresponse field adjusted
%     TASK_NUM the path number (see CNN_CUSTOMTRAIN) that this dataset corresponds to
%   Options:
%     See code comments
% 
% Authors: Zhizhong Li
% 
% See the COPYING file.

opts.partial = 0; % for >0 partial, e.g. 0.3, only include that much portion of # samples.
opts.label = 'multilabel'; % 'multilabel' for 1/0 label for each class, 'nonper/person' for person class label, 'probdist' for a recorded response distribution (uses path.path_OrigNetresponse.VOC)
opts.trainval = [1 2]; % 1 for train, 2 for val. By default include train+val.
opts.randstream = []; % use randstream if provided
opts.setstrings = {'train', 'val'};
opts = vl_argparse(opts, varargin);


if ~isfield(imdb, 'images')
    imdb.images.name = [];
    imdb.images.label = [];
    imdb.images.set = [];
    imdb.images.task = [];
end

sets = opts.setstrings(opts.trainval);

% train or val set
for f = sets
    f = char(f);
    set = 1; if strcmp(f, opts.setstrings{2}), set = 2; end

    % image names
    fid = fopen(fullfile(path.path_VOCmeta, [f '.txt']), 'r');
    readname.(f) = textscan(fid, '%s');
    fclose(fid);

    % selecting partial
    if opts.partial
        if numel(opts.partial)==1
            partial = opts.partial;
        else
            partial = opts.partial(set);
        end
        if isempty(opts.randstream)
            select.(f) = randperm(numel(readname.(f){1}), ceil(numel(readname.(f){1}) * partial));
        else
            select.(f) = randperm(opts.randstream, numel(readname.(f){1}), ceil(numel(readname.(f){1}) * partial));
        end
    else
        select.(f) = 1:numel(readname.(f){1});
    end

    % names
    names = strcat(readname.(f){1}(select.(f)), '.jpg');
    n_set = size(names,1);

    % labels...
    switch opts.label
        case 'probdist'
            % distribution: just load
            probdist = load(path.path_OrigNetresponse.VOC.(f));
            classes = num2cell( probdist.lastfc_out, 1 )';
        case 'nonper/person'
            % nonper/person: just load 1 txt
            fid = fopen(fullfile( path.path_VOCmeta, sprintf('person_%s.txt',f) ));
            readmeta.(f) = textscan(fid, '%s %d');
            fclose(fid);
            
            classes = num2cell(1 + ( readmeta.(f){2} == 1 ));
        case 'multilabel'
            % multi-label: iterate all categories
            txts.(f) = dir(fullfile( path.path_VOCmeta, sprintf('*_%s.txt',f) ));
            classes = zeros( numel(txts.(f)), numel(readname.(f){1}) );
            for i=1:numel(txts.(f))
                fid = fopen(fullfile( path.path_VOCmeta, txts.(f)(i).name ));
                readmeta.(f) = textscan(fid, '%s %d');
                fclose(fid);
                
                classes(i,:) = readmeta.(f){2} == 1;
            end
            classes = num2cell( classes, 1 )';
        otherwise
            throw(MException('opts.label:notRecognized', 'probdist/class/multilabel'));
    end

    classes = classes(select.(f),:);
    
    imdb.images.name = [ imdb.images.name; names ];
    imdb.images.label = [ imdb.images.label; classes ];

    imdb.images.set = [ imdb.images.set;
        ones(n_set,1) * set ];
    imdb.images.task = [ imdb.images.task;
        task_num * ones(n_set, 1) ];
end
